After you run the default DITA-OT HTML5 output, open one of the new HTML files in a validating XML editor like Oxygen. (Just assume that is what I am using all the time, because unless I say otherwise, that is indeed what I am using all the time.) The first thing you may notice is a slew of errors and warnings. Suppress your anger by remembering how much you actually paid for the DITA-OT (US$0.00) and clean it up.

Let's use it as a learning experience. First, let's note the errors and warnings.

In the <head> element, we have a number of issues:

		A document must not include both a “meta” element with an “http-equiv” attribute whose value is “content-type”, and a “meta” element with a “charset” attribute.
		
This is referring to the following two lines:

		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8">

We don't need both of these. Where do they come from? Let's go spelunking down the processing rabbit hole.

From the main (only, for now) XSL in my plugin: dita2html5.xsl, import the main DITA-OT HTML5 XSL. 

		<xsl:import href="plugin:org.dita.html5:xsl/dita2html5Impl.xsl"/>

The handy Oxygen context menu "Open" lets me open the file using the URI extension "plugin:plugin-id". 

I just happen to know that "dita2html5Impl.xsl" imports the XSLT that handles all the generic DITA topic processing: 

		<xsl:import href="plugin:org.dita.html5:xsl/topic.xsl"/>
	
I also happen to know that a named template handles the default processing for HTML files.

		<xsl:template name="chapter-setup">
			<html>
				<xsl:call-template name="setTopicLanguage"/>
				<xsl:call-template name="chapterHead"/>
				<xsl:call-template name="chapterBody"/> 
			</html>
		</xsl:template>

You can probably guess that the named template called here "chapterHead" handles the HTML <head/> element, while "chapterBody" handles <body/>. If so, you would be guessing right. If you want to have some fun, comment out the entire chapterHead template to build "headless" HTML.

"chapterHead" in turn calls template whose mode attribute is "chapterHead" and contains the <head> element. 

Now, this part is weird and I never truly figured it out to my satisfaction, but here is how I more or less fixed this.

WHY TWO CHARACTER ENCODINGS?

It was pretty easy to find out exactly what the W3C says about this at: https://www.w3.org/International/questions/qa-html-encoding-declarations

		Always declare the encoding of your document using a meta element with a charset attribute, or using the http-equiv and content attributes (called a pragma directive). The declaration should fit completely within the first 1024 bytes at the start of the file, so it's best to put it immediately after the opening head tag.

So, we can do one or the other, but not both. So, if we resume our detective work, we find template looks like:

		<xsl:template match="*" mode="chapterHead">
			<head>
			<!-- initial meta information -->
			<xsl:call-template name="generateCharset"/>   <!-- Set the character set to UTF-8 -->
			<xsl:call-template name="generateDefaultCopyright"/> <!-- Generate a default copyright, if needed -->
			<xsl:call-template name="generateDefaultMeta"/> <!-- Standard meta for security, robots, etc -->
			<xsl:call-template name="getMeta"/>           <!-- Process metadata from topic prolog -->
			<xsl:call-template name="copyright"/>         <!-- Generate copyright, if specified manually -->
			<xsl:call-template name="generateCssLinks"/>  <!-- Generate links to CSS files -->
			<xsl:call-template name="generateChapterTitle"/> <!-- Generate the <title> element -->
			<xsl:call-template name="gen-user-head" />    <!-- include user's XSL HEAD processing here -->
			<xsl:call-template name="gen-user-scripts" /> <!-- include user's XSL javascripts here -->
			<xsl:call-template name="gen-user-styles" />  <!-- include user's XSL style element and content here -->
			<xsl:call-template name="processHDF"/>        <!-- Add user HDF file, if specified -->
			</head>
		</xsl:template>

The call to the named template "generateCharset" looks promising, which we find looks like: 

		<xsl:template name="generateCharset">
			<meta charset="UTF-8"/>
		</xsl:template>
		
Looks like the one we need, so we copy the * template to our override XSL and comment out the call to "generateCharset".

Now, I continued to try and determine where the other meta element got generated, and as near as I can figure, it is a default generated by using the XSL output declaration for HTML. I modified it in different ways and got it to change the metadata in the <head>, but figured any benefits would be mostly in the way of satsifying my curiosity, more than any immediate practical gain, so decided to move on.

Besides, we haven't made Oxygen happy yet, as it is still complaining thus: 

		The “scheme” attribute on the “meta” element is obsolete. Use only one scheme per field, or make the scheme declaration part of the value.
		
Looking at the squiggly red lines, it doesn't like these:

			<meta name="DC.relation" scheme="URI" content="work.html"> 
			<meta name="DC.relation" scheme="URI" content="resume.html">
			<meta name="DC.relation" scheme="URI" content="pkm.html">
			<meta name="DC.relation" scheme="URI" content="elements/index.html">

I can understand that meta/@scheme is obsolete, but am not sure what they are calling a "field", or how to make the scheme declaration part of the value (of the element itself?), so decided to go fish. Or, Google.

Giant PITA to get the doctype declaration right, but did it finally.

See this for how: https://stackoverflow.com/questions/3387127/set-html5-doctype-with-xslt