Running a plain vanilla HTML5 override XSLT produces the following errors.

1. A document must not include both a “meta” element with an “http-equiv” attribute whose value is “content-type”, and a “meta” element with a “charset” attribute.

2. The “scheme” attribute on the “meta” element is obsolete. Use only one scheme per field, or make the scheme declaration part of the value. (One of these for every file this topic links directly to.

3. Bad value “toc” for attribute “role” on element “nav”.

4. The “main” role is unnecessary for element “main”.

5. The “article” role is unnecessary for element “article”.

6. The “navigation” role is unnecessary for element “nav”.

7. The “contentinfo” role is unnecessary for element “footer”.

This takes care of Oxygen complaining. In the course of researching (i.e., Googling), I discovered that Oxygen missed something: According to the W3 Validator at https://validator.w3.org/, the doctype was not the best.

8. Warning: Documents should not use about:legacy-compat, except if generated by legacy systems that can't output the standard <!DOCTYPE html> doctype.
================================================================================================














================================================================================================

After you run the default DITA-OT HTML5 output, open one of the new HTML files in a validating XML editor like Oxygen. (Just assume that is what I am using all the time, because unless I say otherwise, that is indeed what I am using all the time.) The first thing you may notice is a slew of errors and warnings. Suppress your anger by remembering how much you actually paid for the DITA-OT (US$0.00) and clean it up.

Let's use it as a learning experience. First, let's note the errors and warnings.

In the <head> element, we have a number of issues:

		A document must not include both a “meta” element with an “http-equiv” attribute whose value is “content-type”, and a “meta” element with a “charset” attribute.
		
This is referring to the following two lines:

		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8">

We don't need both of these. Where do they come from? Let's go spelunking down the processing rabbit hole.

From the main (only, for now) XSL in my plugin: dita2html5.xsl, import the main DITA-OT HTML5 XSL. 

		<xsl:import href="plugin:org.dita.html5:xsl/dita2html5Impl.xsl"/>

The handy Oxygen context menu "Open" lets me open the file using the URI extension "plugin:plugin-id". 

I just happen to know that "dita2html5Impl.xsl" imports the XSLT that handles all the generic DITA topic processing: 

		<xsl:import href="plugin:org.dita.html5:xsl/topic.xsl"/>
	
I also happen to know that a named template handles the default processing for HTML files.

		<xsl:template name="chapter-setup">
			<html>
				<xsl:call-template name="setTopicLanguage"/>
				<xsl:call-template name="chapterHead"/>
				<xsl:call-template name="chapterBody"/> 
			</html>
		</xsl:template>

You can probably guess that the named template called here "chapterHead" handles the HTML <head/> element, while "chapterBody" handles <body/>. If so, you would be guessing right. If you want to have some fun, comment out the entire chapterHead template to build "headless" HTML.

"chapterHead" in turn calls template whose mode attribute is "chapterHead" and contains the <head> element. 

Now, this part is weird and I never truly figured it out to my satisfaction, but here is how I more or less fixed this.

WHY TWO CHARACTER ENCODINGS?

It was pretty easy to find out exactly what the W3C says about this at: https://www.w3.org/International/questions/qa-html-encoding-declarations

		Always declare the encoding of your document using a meta element with a charset attribute, or using the http-equiv and content attributes (called a pragma directive). The declaration should fit completely within the first 1024 bytes at the start of the file, so it's best to put it immediately after the opening head tag.

So, we can do one or the other, but not both. So, if we resume our detective work, we find template looks like:

		<xsl:template match="*" mode="chapterHead">
			<head>
			<!-- initial meta information -->
			<xsl:call-template name="generateCharset"/>   <!-- Set the character set to UTF-8 -->
			<xsl:call-template name="generateDefaultCopyright"/> <!-- Generate a default copyright, if needed -->
			<xsl:call-template name="generateDefaultMeta"/> <!-- Standard meta for security, robots, etc -->
			<xsl:call-template name="getMeta"/>           <!-- Process metadata from topic prolog -->
			<xsl:call-template name="copyright"/>         <!-- Generate copyright, if specified manually -->
			<xsl:call-template name="generateCssLinks"/>  <!-- Generate links to CSS files -->
			<xsl:call-template name="generateChapterTitle"/> <!-- Generate the <title> element -->
			<xsl:call-template name="gen-user-head" />    <!-- include user's XSL HEAD processing here -->
			<xsl:call-template name="gen-user-scripts" /> <!-- include user's XSL javascripts here -->
			<xsl:call-template name="gen-user-styles" />  <!-- include user's XSL style element and content here -->
			<xsl:call-template name="processHDF"/>        <!-- Add user HDF file, if specified -->
			</head>
		</xsl:template>

The call to the named template "generateCharset" looks promising, which we find looks like: 

		<xsl:template name="generateCharset">
			<meta charset="UTF-8"/>
		</xsl:template>
		
Looks like the one we need, so we copy the * template to our override XSL and comment out the call to "generateCharset".

Now, I continued to try and determine where the other meta element got generated, and as near as I can figure, it is a default generated by using the XSL output declaration for HTML. I modified it in different ways and got it to change the metadata in the <head>, but figured any benefits would be mostly in the way of satsifying my curiosity, more than any immediate practical gain, so decided to move on.

Besides, we haven't made Oxygen happy yet, as it is still complaining thus: 

		The “scheme” attribute on the “meta” element is obsolete. Use only one scheme per field, or make the scheme declaration part of the value.
		
Looking at the squiggly red lines, it doesn't like these:

			<meta name="DC.relation" scheme="URI" content="work.html"> 
			<meta name="DC.relation" scheme="URI" content="resume.html">
			<meta name="DC.relation" scheme="URI" content="pkm.html">
			<meta name="DC.relation" scheme="URI" content="elements/index.html">

I can understand that meta/@scheme is obsolete, but am not sure what they are calling a "field", or how to make the scheme declaration part of the value (of the element itself?), so decided to go fish. Or, Google.

-----------------------------------------------------------------------------------------------

Google did me no good, so I commented out different things until I found that the <xsl:call-template> for the named template "getMeta" is what produces these. 

    <meta name="DC.type" content="topic">
    <meta name="DC.relation" scheme="URI" content="work.html">
    <meta name="DC.relation" scheme="URI" content="resume.html">
    <meta name="DC.relation" scheme="URI" content="pkm.html">
    <meta name="DC.relation" scheme="URI" content="elements/index.html">
    <meta name="DC.format" content="HTML5">
    <meta name="DC.identifier" content="topic_kgw_4l5_h4b">
	
The only ones we want to revise are the ones with "scheme="URI"", so we can search for that or "DC.relation". Either way, it leads to:

      <meta name="DC.relation" scheme="URI">
        <xsl:attribute name="content"><xsl:value-of select="$linkmeta_ext"/></xsl:attribute>
      </meta>
	  
Copy that entire template and paste it into the override XSLT and make the change there. In digging around and experimenting with what would pass the W3 Validator, I found this revision to work for the scheme attribute errors.

        <meta name="DC.relation.uri">
          <xsl:attribute name="content"><xsl:value-of select="$linkmeta_ext"/></xsl:attribute>
        </meta>

-----------------------------------------------------------------------------------------------

Next up are the "role" attribute warnings. Some research reveals that <nav> cannot contain a role attribute. Searching in files for the opening tag of the nav element, it looks like any element can be processed with mode "gen-user-sidetoc". One fix would be to simply remove the "use-attribute-sets" and that will eliminate the issue. 

  <xsl:template match="*" mode="gen-user-sidetoc">
    <xsl:if test="$nav-toc = ('partial', 'full')">
      <nav xsl:use-attribute-sets="toc">
        <ul>
          <xsl:choose>
            <xsl:when test="$nav-toc = 'partial'">
              <xsl:apply-templates select="$current-topicref" mode="toc-pull">
                <xsl:with-param name="pathFromMaplist" select="$PATH2PROJ" as="xs:string"/>
                <xsl:with-param name="children" as="element()*">
                    <xsl:apply-templates select="$current-topicref/*[contains(@class, ' map/topicref ')]" mode="toc">
                    <xsl:with-param name="pathFromMaplist" select="$PATH2PROJ" as="xs:string"/>
                  </xsl:apply-templates>
                </xsl:with-param>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="$nav-toc = 'full'">
              <xsl:apply-templates select="$input.map" mode="toc">
                <xsl:with-param name="pathFromMaplist" select="$PATH2PROJ" as="xs:string"/>
              </xsl:apply-templates>
            </xsl:when>
          </xsl:choose>
        </ul>
      </nav>
    </xsl:if>
  </xsl:template>
  
You could also change the attribute set to not add an attribute at all, but if you want to keep everything in an override plugin XSLT, you still need this template to call it in the first place.
  
But, what calls it to begin with? Ah, yes. The "gen-user-sidetoc" that you are supposed to override. 

<xsl:template name="gen-user-sidetoc">
  <xsl:apply-templates select="." mode="gen-user-sidetoc"/>
</xsl:template>

<xsl:template match="/|node()|@*" mode="gen-user-sidetoc">
  <!-- to customize: copy this to your override transform, add the content you want. -->
  <!-- Uncomment the line below to have a "freebie" table of contents on the top-right -->
</xsl:template>

This is, of course, some leftover from XHTML (you can find it in the xhtml plugin) that was probably originally intended as a "sub-toc" for individual pages. I imagine it got repurposed and whoever added it here simply left the old comments in. 

Regardless, the named template gets called from "cover.xsl" and "topic.xsl"; it gets matched on "*" from "nav.xsl"; and the named template appears in "topic.xsl", along with apply-templates for the current node and a match to any node. 

To customize, let's do what it says above, copy the template for any node or attribute to our override. You can put anything in there and it gets rendered into the output.

The one that does the magic (or the processing; let's not be silly) is the "star" matcher: <xsl:template match="*" mode="gen-user-sidetoc">

That is where the illegal "role" attribute gets included and so we need to copy that into our override XSLT.

If we simply copy and paste that star matched template into our override, we don't get any of our silly output we may have included with the node matcher.

Now, if we look at the star-matched template, we see there is a big, honking if statement that the template is wrapped around. So, as an experiment, I copied the if, commented out my star-matched template, and pasted the if inside the node matcher in my override XSLT.

It looks as if it works, so I will remove the role attribute here and that should do what we want. 

And we can do the same thing for <xsl:template match="*" mode="addContentToHtmlBodyElement"> in "topic.xsl" to get rid of the attributes in main and article. 

Now, look for the template that inserts the role "contentinfo" in the footer and remove that attribute set.

Oops. We have another role for a nav; this time, for the related-links. So, we copy the big, hairy <xsl:template match="*[contains(@class, ' topic/related-links ')]" name="topic.related-links"> just to eliminate an attribute set. And, while we are at it, we can comment out the call to "commonattributes" since all it does is add "class="related-links"". We can add it back if we want.

Now, what does all that do? Ack!

	Warning: Documents should not use about:legacy-compat, except if generated by legacy systems that can't output the standard <!DOCTYPE html> doctype.
	
Not a problem. We use Dirk Vollmar's hack below. (Replacing his <html></html> with <xsl:apply-templates/>.)

And now, ta-da!

	Document checking completed. No errors or warnings to show.
-----------------------------------------------------------------------------------------------
DOCTYPE

asked Aug 2 '10 at 11:08

Jon Hadley

https://stackoverflow.com/questions/3387127/set-html5-doctype-with-xslt

answered Aug 2 '10 at 12:05

Dirk Vollmar

 <?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="html" encoding="utf-8" indent="yes" />

  <xsl:template match="/">
    <xsl:text disable-output-escaping='yes'>&lt;!DOCTYPE html&gt;</xsl:text>
    <html>
    </html>
  </xsl:template>

</xsl:stylesheet>
This will produce the following output:

<!DOCTYPE html>
<html>
</html>

-----------------------------------------------------------------------------------------------